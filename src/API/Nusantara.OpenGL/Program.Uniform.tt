// <https://github.com/YvvkiRika> wrote this file.
// As long as you retain this notice, you can do whatever you want with this stuff.

<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" #>
<#
void Uniform(string type)
{
	Uniform1(type);
	UniformD(type, 2);
	UniformD(type, 3);
	UniformD(type, 4);
}

void Uniform1(string type)
{
#>
	public void Uniform1(int location, <#= type #> v0)
	{
		lock (GL)
		{
			GL.ProgramUniform1(Handle, location, v0);
		}
	}

	public void Uniform1(string name, <#= type #> v0)
	{
		int location = GetUniformLocation(name);
		Uniform1(location, v0);
	}

	public void Uniform1(int location, ReadOnlySpan<<#= type #>> value)
	{
		lock (GL)
		{
			GL.ProgramUniform1(Handle, location, value);
		}
	}

	public void Uniform1(string name, ReadOnlySpan<<#= type #>> value)
	{
		int location = GetUniformLocation(name);
		Uniform1(location, value);
	}

	public void Uniform1(int location, params <#= type #>[] value)
	{
		Uniform1(location, value.AsSpan());
	}

	public void Uniform1(string name, params <#= type #>[] value)
	{
		int location = GetUniformLocation(name);
		Uniform1(location, value);
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public void Uniform1(int location, ReadOnlySpan<ValueTuple<<#= type #>>> value)
	{
		ReadOnlySpan<<#= type #>> value1 = MemoryMarshal.Cast<ValueTuple<<#= type #>>, <#= type #>>(value);
		Uniform1(location, value1);
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public void Uniform1(string name, ReadOnlySpan<ValueTuple<<#= type #>>> value)
	{
		int location = GetUniformLocation(name);
		Uniform1(location, value);
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public void Uniform1(int location, params ValueTuple<<#= type #>>[] value)
	{
		Uniform1(location, value.AsSpan());
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public void Uniform1(string name, params ValueTuple<<#= type #>>[] value)
	{
		int location = GetUniformLocation(name);
		Uniform1(location, value);
	}

<#
}

char[] _symbols = { 'X', 'Y', 'Z', 'W' };
char[] GetSymbols(char[] symbols, int index, int count)
{
	char[] result = new char[count];
	Array.Copy(symbols, index, result, 0, count);

	return result;
}

string GetValueTupleType(string type, int count)
{
	return "ValueTuple<" + string.Join(", ", Enumerable.Repeat(type, count)) + ">";
}

void UniformD(string type, int count)
{
	string vParameterDeclare = string.Join(", ", Enumerable.Range(0, count).Select(index => $"{type} v{index}"));
	string vParameterInvoke = string.Join(", ", Enumerable.Range(0, count).Select(index => $"v{index}"));

	string ValueTupleType = GetValueTupleType(type, count);
#>
	public void Uniform<#= count #>(int location, <#= vParameterDeclare #>)
	{
		lock (GL)
		{
			GL.ProgramUniform<#= count #>(Handle, location, <#= vParameterInvoke #>);
		}
	}

	public void Uniform<#= count #>(string name, <#= vParameterDeclare #>)
	{
		int location = GetUniformLocation(name);
		Uniform<#= count #>(location, <#= vParameterInvoke #>);
	}

	public void Uniform<#= count #>(int location, ReadOnlySpan<<#= ValueTupleType #>> value)
	{
		lock (GL)
		{
			GL.ProgramUniform<#= count #>(Handle, location, (uint)value.Length, MemoryMarshal.Cast<<#= ValueTupleType #>, <#= type #>>(value));
		}
	}

	public void Uniform<#= count #>(string name, ReadOnlySpan<<#= ValueTupleType #>> value)
	{
		int location = GetUniformLocation(name);
		Uniform<#= count #>(location, value);
	}

	public void Uniform<#= count #>(int location, params <#= ValueTupleType #>[] value)
	{
		Uniform<#= count #>(location, value.AsSpan());
	}

	public void Uniform<#= count #>(string name, params <#= ValueTupleType #>[] value)
	{
		int location = GetUniformLocation(name);
		Uniform<#= count #>(location, value);
	}

<#
	UniformVector(count, type, $"Vector{count}D<{type}>");
}

void UniformVector(int count, string type, string vectorName)
{
	string ValueTupleType = GetValueTupleType(type, count);

#>
	public void Uniform<#= count #>(int location, <#= vectorName #> vector)
	{
		Uniform<#= count #>(
			location,
			<#= string.Join(@",
			", GetSymbols(_symbols, 0, count).Select(symbol => $"vector.{symbol}"))#>);
	}

	public void Uniform<#= count #>(string name, <#= vectorName #> vector)
	{
		Uniform<#= count #>(
			name,
			<#= string.Join(@",
			", GetSymbols(_symbols, 0, count).Select(symbol => $"vector.{symbol}"))#>);
	}

	public void Uniform<#= count #>(int location, ReadOnlySpan<<#= vectorName #>> value)
	{
		Uniform<#= count #>(location, MemoryMarshal.Cast<<#= vectorName #>, <#= ValueTupleType #>>(value));
	}

	public void Uniform<#= count #>(string name, ReadOnlySpan<<#= vectorName #>> value)
	{
		int location = GetUniformLocation(name);
		Uniform<#= count #>(location, value);
	}

	public void Uniform<#= count #>(int location, params <#= vectorName #>[] value)
	{
		Uniform<#= count #>(location, value.AsSpan());
	}

	public void Uniform<#= count #>(string name, params <#= vectorName #>[] value)
	{
		int location = GetUniformLocation(name);
		Uniform<#= count #>(location, value);
	}

<#
}

void UniformMatrix(string type)
{
	UniformMatrixD(type, $"Matrix2X2<{type}>", "2");
	UniformMatrixD(type, $"Matrix2X3<{type}>", "2x3");
	UniformMatrixD(type, $"Matrix2X4<{type}>", "2x4");

	UniformMatrixD(type, $"Matrix3X2<{type}>", "3x2");
	UniformMatrixD(type, $"Matrix3X3<{type}>", "3");
	UniformMatrixD(type, $"Matrix3X4<{type}>", "3x4");

	UniformMatrixD(type, $"Matrix4X2<{type}>", "4x2");
	UniformMatrixD(type, $"Matrix4X3<{type}>", "4x3");
	UniformMatrixD(type, $"Matrix4X4<{type}>", "4");
}

void UniformMatrixD(string type, string matrixType, string glMatrixDimension)
{
#>
	public void UniformMatrix<#= glMatrixDimension #>(int location, bool transpose, ReadOnlySpan<<#= matrixType #>> value)
	{
		lock (GL)
		{
			GL.ProgramUniformMatrix<#= glMatrixDimension #>(
				Handle,
				location,
				(uint)value.Length,
				transpose,
				MemoryMarshal.Cast<<#= matrixType #>, <#= type #>>(value));
		}
	}

	public unsafe void UniformMatrix<#= glMatrixDimension #>(string name, bool transpose, ReadOnlySpan<<#= matrixType #>> value)
	{
		int location = GetUniformLocation(name);
		UniformMatrix<#= glMatrixDimension #>(location, transpose, value);
	}

	public unsafe void UniformMatrix<#= glMatrixDimension #>(int location, bool transpose = false, params <#= matrixType #>[] value)
	{
		UniformMatrix<#= glMatrixDimension #>(location, transpose, value.AsSpan());
	}

	public unsafe void UniformMatrix<#= glMatrixDimension #>(string name, bool transpose = false, params <#= matrixType #>[] value)
	{
		int location = GetUniformLocation(name);
		UniformMatrix<#= glMatrixDimension #>(location, transpose, value);
	}

<#
}
#>
using System.ComponentModel;
using System.Numerics;
using System.Runtime.InteropServices;

using Silk.NET.Maths;
using Silk.NET.OpenGL;

namespace Nusantara.OpenGL;

public partial class Program
{
<#
	Uniform("int");
	Uniform("uint");
	Uniform("float");
	UniformVector(2, "float", "Vector2");
	UniformVector(3, "float", "Vector3");
	UniformVector(4, "float", "Vector4");
	Uniform("double");

	UniformMatrix("float");
	UniformMatrixD("float", "Matrix3x2", "3x2");
	UniformMatrixD("float", "Matrix4x4", "4");
	UniformMatrix("double");
#>
}
